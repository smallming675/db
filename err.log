Checking src/executor/column.c ...
1/20 files checked 0% done
Checking src/executor/eval.c ...
2/20 files checked 5% done
Checking src/executor/output.c ...
3/20 files checked 7% done
Checking src/executor/scalar.c ...
4/20 files checked 11% done
Checking src/executor.c ...
src/executor.c:447:10: warning: If memory allocation fails, then there is a possible null pointer dereference: result_copy [nullPointerOutOfMemory]
        *result_copy = result;
         ^
src/executor.c:446:44: note: Assuming allocation function fails
        Value* result_copy = (Value*)malloc(sizeof(Value));
                                           ^
src/executor.c:446:30: note: Assignment 'result_copy=(Value*)malloc(sizeof(Value))', assigned value is 0
        Value* result_copy = (Value*)malloc(sizeof(Value));
                             ^
src/executor.c:447:10: note: Null pointer dereference
        *result_copy = result;
         ^
5/20 files checked 24% done
Checking src/logger.c ...
6/20 files checked 26% done
Checking src/main.c ...
7/20 files checked 28% done
Checking src/parser.c ...
src/parser.c:1201:9: error: Memory leak: expr [memleak]
        return inner;
        ^
src/parser.c:1565:5: error: Memory leak: star_expr [memleak]
    } else {
    ^
src/parser.c:1225:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->type = EXPR_UNARY_OP;
        ^
src/parser.c:1224:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1224:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1225:9: note: Null pointer dereference
        expr->type = EXPR_UNARY_OP;
        ^
src/parser.c:1226:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->unary.op = OP_NOT;
        ^
src/parser.c:1224:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1224:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1226:9: note: Null pointer dereference
        expr->unary.op = OP_NOT;
        ^
src/parser.c:1228:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->unary.operand = parse_unary_expr(ctx);
        ^
src/parser.c:1224:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1224:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1228:9: note: Null pointer dereference
        expr->unary.operand = parse_unary_expr(ctx);
        ^
src/parser.c:1229:14: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        if (!expr->unary.operand) {
             ^
src/parser.c:1224:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1224:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1229:14: note: Null pointer dereference
        if (!expr->unary.operand) {
             ^
src/parser.c:1238:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->type = EXPR_SUBQUERY;
        ^
src/parser.c:1237:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1237:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1238:9: note: Null pointer dereference
        expr->type = EXPR_SUBQUERY;
        ^
src/parser.c:1310:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1309:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1309:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1310:9: note: Null pointer dereference
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1343:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.op = op;
        ^
src/parser.c:1309:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1309:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1343:9: note: Null pointer dereference
        expr->binary.op = op;
        ^
src/parser.c:1344:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.left = left;
        ^
src/parser.c:1309:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1309:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1344:9: note: Null pointer dereference
        expr->binary.left = left;
        ^
src/parser.c:1345:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.right = parse_unary_expr(ctx);
        ^
src/parser.c:1309:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1309:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1345:9: note: Null pointer dereference
        expr->binary.right = parse_unary_expr(ctx);
        ^
src/parser.c:1346:14: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        if (!expr->binary.right) {
             ^
src/parser.c:1309:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1309:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1346:14: note: Null pointer dereference
        if (!expr->binary.right) {
             ^
src/parser.c:1368:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1367:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1367:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1368:9: note: Null pointer dereference
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1369:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.op = OP_AND;
        ^
src/parser.c:1367:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1367:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1369:9: note: Null pointer dereference
        expr->binary.op = OP_AND;
        ^
src/parser.c:1371:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.left = left;
        ^
src/parser.c:1367:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1367:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1371:9: note: Null pointer dereference
        expr->binary.left = left;
        ^
src/parser.c:1372:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.right = parse_comparison_expr(ctx);
        ^
src/parser.c:1367:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1367:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1372:9: note: Null pointer dereference
        expr->binary.right = parse_comparison_expr(ctx);
        ^
src/parser.c:1373:14: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        if (!expr->binary.right) {
             ^
src/parser.c:1367:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1367:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1373:14: note: Null pointer dereference
        if (!expr->binary.right) {
             ^
src/parser.c:1395:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1394:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1394:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1395:9: note: Null pointer dereference
        expr->type = EXPR_BINARY_OP;
        ^
src/parser.c:1396:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.op = OP_OR;
        ^
src/parser.c:1394:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1394:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1396:9: note: Null pointer dereference
        expr->binary.op = OP_OR;
        ^
src/parser.c:1398:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.left = left;
        ^
src/parser.c:1394:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1394:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1398:9: note: Null pointer dereference
        expr->binary.left = left;
        ^
src/parser.c:1399:9: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        expr->binary.right = parse_and_expr(ctx);
        ^
src/parser.c:1394:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1394:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1399:9: note: Null pointer dereference
        expr->binary.right = parse_and_expr(ctx);
        ^
src/parser.c:1400:14: warning: If memory allocation fails, then there is a possible null pointer dereference: expr [nullPointerOutOfMemory]
        if (!expr->binary.right) {
             ^
src/parser.c:1394:28: note: Assuming allocation function fails
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1394:28: note: Assignment 'expr=malloc(sizeof(Expr))', assigned value is 0
        Expr* expr = malloc(sizeof(Expr));
                           ^
src/parser.c:1400:14: note: Null pointer dereference
        if (!expr->binary.right) {
             ^
8/20 files checked 66% done
Checking src/table.c ...
9/20 files checked 72% done
Checking src/tests/test_aggregates.c ...
10/20 files checked 74% done
Checking src/tests/test_ddl.c ...
11/20 files checked 75% done
Checking src/tests/test_dml.c ...
12/20 files checked 78% done
Checking src/tests/test_joins.c ...
13/20 files checked 80% done
Checking src/tests/test_scalar.c ...
14/20 files checked 82% done
Checking src/tests/test_select.c ...
15/20 files checked 85% done
Checking src/tests/test_subqueries.c ...
16/20 files checked 87% done
Checking src/tests/test_util.c ...
17/20 files checked 89% done
Checking src/tests/tests.c ...
18/20 files checked 91% done
Checking src/tokenizer.c ...
19/20 files checked 96% done
Checking src/values.c ...
20/20 files checked 100% done
src/executor.c:848:14: style: The function 'exec_query' is never used. [unusedFunction]
QueryResult* exec_query(const char* sql) {
             ^
src/executor/output.c:101:6: style: The function 'print_result_row' is never used. [unusedFunction]
void print_result_row(const Value* values, int col_count) {
     ^
src/executor/output.c:109:6: style: The function 'print_column_headers' is never used. [unusedFunction]
void print_column_headers(SelectNode* select, Table* table, bool is_select_star, int col_count) {
     ^
src/logger.c:84:6: style: The function 'suggest_similar' is never used. [unusedFunction]
void suggest_similar(const char *input, const char *candidates[], int candidate_count,
     ^
src/logger.c:107:10: style: The function 'log_level_from_str' is never used. [unusedFunction]
LogLevel log_level_from_str(const char* level_str) {
         ^
src/logger.c:135:6: style: The function 'show_prominent_error' is never used. [unusedFunction]
void show_prominent_error(const char* fmt, ...) {
     ^
src/table.c:33:6: style: The function 'create_row' is never used. [unusedFunction]
Row* create_row(int initial_capacity) {
     ^
src/table.c:49:6: style: The function 'free_row' is never used. [unusedFunction]
void free_row(Row* row) {
     ^
src/table.c:63:5: style: The function 'resize_row' is never used. [unusedFunction]
int resize_row(Row* row, int new_capacity) {
    ^
src/table.c:93:8: style: The function 'create_table' is never used. [unusedFunction]
Table* create_table(const char* name, int initial_row_capacity) {
       ^
src/table.c:114:6: style: The function 'free_table' is never used. [unusedFunction]
void free_table(Table* table) {
     ^
src/table.c:124:5: style: The function 'resize_table' is never used. [unusedFunction]
int resize_table(Table* table, int new_capacity) {
    ^
src/table.c:212:6: style: The function 'check_not_null_constraint' is never used. [unusedFunction]
bool check_not_null_constraint(Table* table, int col_idx, Value* val) {
     ^
src/table.c:222:6: style: The function 'check_unique_constraint' is never used. [unusedFunction]
bool check_unique_constraint(Table* table, int col_idx, Value* val, int exclude_row_idx) {
     ^
src/table.c:239:6: style: The function 'check_foreign_key_constraint' is never used. [unusedFunction]
bool check_foreign_key_constraint(Table* table, int col_idx, Value* val) {
     ^
src/tests/test_aggregates.c:11:6: style: The function 'test_count_aggregate' is never used. [unusedFunction]
void test_count_aggregate(void) {
     ^
src/tests/test_aggregates.c:28:6: style: The function 'test_sum_aggregate' is never used. [unusedFunction]
void test_sum_aggregate(void) {
     ^
src/tests/test_aggregates.c:44:6: style: The function 'test_avg_aggregate' is never used. [unusedFunction]
void test_avg_aggregate(void) {
     ^
src/tests/test_aggregates.c:60:6: style: The function 'test_min_aggregate' is never used. [unusedFunction]
void test_min_aggregate(void) {
     ^
src/tests/test_aggregates.c:76:6: style: The function 'test_max_aggregate' is never used. [unusedFunction]
void test_max_aggregate(void) {
     ^
src/tests/test_aggregates.c:92:6: style: The function 'test_multiple_aggregates' is never used. [unusedFunction]
void test_multiple_aggregates(void) {
     ^
src/tests/test_aggregates.c:107:6: style: The function 'test_aggregate_with_where' is never used. [unusedFunction]
void test_aggregate_with_where(void) {
     ^
src/tests/test_aggregates.c:126:6: style: The function 'test_aggregate_edge_cases' is never used. [unusedFunction]
void test_aggregate_edge_cases(void) {
     ^
src/tests/test_aggregates.c:148:6: style: The function 'test_count_all_vs_column' is never used. [unusedFunction]
void test_count_all_vs_column(void) {
     ^
src/tests/test_ddl.c:10:6: style: The function 'test_create_table' is never used. [unusedFunction]
void test_create_table(void) {
     ^
src/tests/test_ddl.c:35:6: style: The function 'test_drop_table' is never used. [unusedFunction]
void test_drop_table(void) {
     ^
src/tests/test_ddl.c:51:6: style: The function 'test_create_table_with_foreign_key' is never used. [unusedFunction]
void test_create_table_with_foreign_key(void) {
     ^
src/tests/test_ddl.c:65:6: style: The function 'test_create_table_multiple_columns' is never used. [unusedFunction]
void test_create_table_multiple_columns(void) {
     ^
src/tests/test_dml.c:10:6: style: The function 'test_insert_single_row' is never used. [unusedFunction]
void test_insert_single_row(void) {
     ^
src/tests/test_dml.c:29:6: style: The function 'test_insert_multiple_values' is never used. [unusedFunction]
void test_insert_multiple_values(void) {
     ^
src/tests/test_dml.c:51:6: style: The function 'test_insert_mixed_types' is never used. [unusedFunction]
void test_insert_mixed_types(void) {
     ^
src/tests/test_dml.c:77:6: style: The function 'test_update_single_row' is never used. [unusedFunction]
void test_update_single_row(void) {
     ^
src/tests/test_dml.c:95:6: style: The function 'test_update_multiple_rows' is never used. [unusedFunction]
void test_update_multiple_rows(void) {
     ^
src/tests/test_dml.c:113:6: style: The function 'test_update_all_rows' is never used. [unusedFunction]
void test_update_all_rows(void) {
     ^
src/tests/test_dml.c:131:6: style: The function 'test_delete_single_row' is never used. [unusedFunction]
void test_delete_single_row(void) {
     ^
src/tests/test_dml.c:148:6: style: The function 'test_delete_multiple_rows' is never used. [unusedFunction]
void test_delete_multiple_rows(void) {
     ^
src/tests/test_dml.c:166:6: style: The function 'test_delete_all_rows' is never used. [unusedFunction]
void test_delete_all_rows(void) {
     ^
src/tests/test_dml.c:183:6: style: The function 'test_insert_with_comments' is never used. [unusedFunction]
void test_insert_with_comments(void) {
     ^
src/tests/test_dml.c:199:6: style: The function 'test_multiple_statements' is never used. [unusedFunction]
void test_multiple_statements(void) {
     ^
src/tests/test_joins.c:10:6: style: The function 'test_inner_join' is never used. [unusedFunction]
void test_inner_join(void) {
     ^
src/tests/test_joins.c:30:6: style: The function 'test_left_join' is never used. [unusedFunction]
void test_left_join(void) {
     ^
src/tests/test_joins.c:49:6: style: The function 'test_join_multiple_matches' is never used. [unusedFunction]
void test_join_multiple_matches(void) {
     ^
src/tests/test_joins.c:68:6: style: The function 'test_join_no_matches' is never used. [unusedFunction]
void test_join_no_matches(void) {
     ^
src/tests/test_joins.c:86:6: style: The function 'test_join_empty_table' is never used. [unusedFunction]
void test_join_empty_table(void) {
     ^
src/tests/test_joins.c:102:6: style: The function 'test_join_syntax_variations' is never used. [unusedFunction]
void test_join_syntax_variations(void) {
     ^
src/tests/test_joins.c:121:6: style: The function 'test_self_join' is never used. [unusedFunction]
void test_self_join(void) {
     ^
src/tests/test_joins.c:139:6: style: The function 'test_three_table_join' is never used. [unusedFunction]
void test_three_table_join(void) {
     ^
src/tests/test_scalar.c:11:6: style: The function 'test_string_functions' is never used. [unusedFunction]
void test_string_functions(void) {
     ^
src/tests/test_scalar.c:28:6: style: The function 'test_numeric_functions' is never used. [unusedFunction]
void test_numeric_functions(void) {
     ^
src/tests/test_scalar.c:47:6: style: The function 'test_concat_function' is never used. [unusedFunction]
void test_concat_function(void) {
     ^
src/tests/test_scalar.c:61:6: style: The function 'test_substring_function' is never used. [unusedFunction]
void test_substring_function(void) {
     ^
src/tests/test_scalar.c:76:6: style: The function 'test_length_function' is never used. [unusedFunction]
void test_length_function(void) {
     ^
src/tests/test_scalar.c:91:6: style: The function 'test_mod_function' is never used. [unusedFunction]
void test_mod_function(void) {
     ^
src/tests/test_scalar.c:106:6: style: The function 'test_power_function' is never used. [unusedFunction]
void test_power_function(void) {
     ^
src/tests/test_scalar.c:121:6: style: The function 'test_mid_function' is never used. [unusedFunction]
void test_mid_function(void) {
     ^
src/tests/test_scalar.c:135:6: style: The function 'test_scalar_in_expressions' is never used. [unusedFunction]
void test_scalar_in_expressions(void) {
     ^
src/tests/test_select.c:10:6: style: The function 'test_select_all' is never used. [unusedFunction]
void test_select_all(void) {
     ^
src/tests/test_select.c:28:6: style: The function 'test_select_columns' is never used. [unusedFunction]
void test_select_columns(void) {
     ^
src/tests/test_select.c:41:6: style: The function 'test_select_with_where' is never used. [unusedFunction]
void test_select_with_where(void) {
     ^
src/tests/test_select.c:59:6: style: The function 'test_select_with_and_or' is never used. [unusedFunction]
void test_select_with_and_or(void) {
     ^
src/tests/test_select.c:79:6: style: The function 'test_select_with_like' is never used. [unusedFunction]
void test_select_with_like(void) {
     ^
src/tests/test_select.c:97:6: style: The function 'test_select_with_order_by' is never used. [unusedFunction]
void test_select_with_order_by(void) {
     ^
src/tests/test_select.c:111:6: style: The function 'test_select_with_limit' is never used. [unusedFunction]
void test_select_with_limit(void) {
     ^
src/tests/test_select.c:124:6: style: The function 'test_select_with_order_by_limit' is never used. [unusedFunction]
void test_select_with_order_by_limit(void) {
     ^
src/tests/test_select.c:173:6: style: The function 'test_select_case_sensitivity' is never used. [unusedFunction]
void test_select_case_sensitivity(void) {
     ^
src/tests/test_subqueries.c:10:6: style: The function 'test_subquery_with_comparison' is never used. [unusedFunction]
void test_subquery_with_comparison(void) {
     ^
src/tests/test_subqueries.c:32:6: style: The function 'test_correlated_subquery' is never used. [unusedFunction]
void test_correlated_subquery(void) {
     ^
src/tests/test_subqueries.c:50:6: style: The function 'test_subquery_in_insert' is never used. [unusedFunction]
void test_subquery_in_insert(void) {
     ^
src/tests/test_subqueries.c:65:6: style: The function 'test_subquery_with_aggregates' is never used. [unusedFunction]
void test_subquery_with_aggregates(void) {
     ^
src/tests/test_subqueries.c:81:6: style: The function 'test_exists_subquery' is never used. [unusedFunction]
void test_exists_subquery(void) {
     ^
src/tests/test_subqueries.c:97:6: style: The function 'test_nested_subquery' is never used. [unusedFunction]
void test_nested_subquery(void) {
     ^
src/tests/test_subqueries.c:114:6: style: The function 'test_subquery_with_join' is never used. [unusedFunction]
void test_subquery_with_join(void) {
     ^
src/tests/test_subqueries.c:134:6: style: The function 'test_scalar_subquery' is never used. [unusedFunction]
void test_scalar_subquery(void) {
     ^
src/tests/test_util.c:80:6: style: The function 'assert_false' is never used. [unusedFunction]
void assert_false(bool condition, const char* format, ...) { assert_true(!condition, format); }
     ^
src/tests/test_util.c:94:6: style: The function 'assert_str_eq' is never used. [unusedFunction]
void assert_str_eq(const char* expected, const char* actual, const char* format, ...) {
     ^
src/tests/test_util.c:129:6: style: The function 'assert_ptr_null' is never used. [unusedFunction]
void assert_ptr_null(void* ptr, const char* format, ...) {
     ^
src/tests/test_util.c:141:6: style: The function 'assert_float_eq' is never used. [unusedFunction]
void assert_float_eq(double expected, double actual, double epsilon, const char* format, ...) {
     ^
src/values.c:89:7: style: The function 'convert_value' is never used. [unusedFunction]
Value convert_value(const Value* val, DataType target_type) {
      ^
src/values.c:94:6: style: The function 'try_convert_value' is never used. [unusedFunction]
bool try_convert_value(const Value* val, DataType target_type, Value* out_result) {
     ^
src/values.c:266:7: style: The function 'compute_aggregate' is never used. [unusedFunction]
Value compute_aggregate(AggFuncType func_type, AggState* state, DataType return_type) {
      ^
src/executor/eval.c:66:6: style: The function 'eval_cmp_operation' should have static linkage since it is not used outside of its translation unit. [staticFunction]
bool eval_cmp_operation(const Expr* expr, const Row* row, const TableDef* left_schema,
     ^
src/executor/eval.c:90:6: style: The function 'eval_binary_operation' should have static linkage since it is not used outside of its translation unit. [staticFunction]
bool eval_binary_operation(const Expr* expr, const Row* row, const TableDef* left_schema,
     ^
src/executor/output.c:56:6: style: The function 'print_table_separator' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void print_table_separator(ColumnWidth* col_widths, int col_count) {
     ^
src/executor/output.c:69:6: style: The function 'print_table_header' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void print_table_header(QueryResult* result, ColumnWidth* col_widths, int col_count) {
     ^
src/executor/output.c:82:6: style: The function 'print_row_data' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void print_row_data(QueryResult* result, ColumnWidth* col_widths, int col_count, int row_idx) {
     ^
src/parser.c:148:13: style: The function 'token_type_name' should have static linkage since it is not used outside of its translation unit. [staticFunction]
const char* token_type_name(TokenType type) {
            ^
src/parser.c:360:6: style: The function 'parse_error_init' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void parse_error_init(ParseContext* ctx, const char* input, Token* tokens, int token_count) {
     ^
src/parser.c:374:6: style: The function 'parse_error_set' should have static linkage since it is not used outside of its translation unit. [staticFunction]
void parse_error_set(ParseContext* ctx, ParseErrorCode code, const char* message,
     ^
src/parser.c:533:13: style: The function 'parse_error_code_str' should have static linkage since it is not used outside of its translation unit. [staticFunction]
const char* parse_error_code_str(ParseErrorCode code) {
            ^
src/parser.c:2122:10: style: The function 'parse_with_context' should have static linkage since it is not used outside of its translation unit. [staticFunction]
ASTNode* parse_with_context(ParseContext* ctx, Token* tokens) {
         ^
src/table.c:130:7: style: The function 'copy_value' should have static linkage since it is not used outside of its translation unit. [staticFunction]
Value copy_value(const Value* src) {
      ^
src/table.c:182:8: style: The function 'get_table' should have static linkage since it is not used outside of its translation unit. [staticFunction]
Table* get_table(const char* name) { return find_table(name); }
       ^
src/table.c:195:6: style: The function 'value_equals' should have static linkage since it is not used outside of its translation unit. [staticFunction]
bool value_equals(const Value* a, const Value* b) {
     ^
src/table.c:302:5: style: The function 'hash_value' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int hash_value(const Value* value, int bucket_count) {
    ^
src/table.c:362:8: style: The function 'find_index' should have static linkage since it is not used outside of its translation unit. [staticFunction]
Index* find_index(const char* index_name) {
       ^
src/values.c:12:5: style: The function 'time_hour' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int time_hour(unsigned int time_val) { return (time_val >> 12) & 0xFF; }
    ^
src/values.c:13:5: style: The function 'time_minute' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int time_minute(unsigned int time_val) { return (time_val >> 6) & 0x3F; }
    ^
src/values.c:14:5: style: The function 'time_second' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int time_second(unsigned int time_val) { return time_val & 0x3F; }
    ^
src/values.c:15:5: style: The function 'date_year' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int date_year(unsigned int date_val) { return (date_val >> 9) & 0x3FFFFF; }
    ^
src/values.c:16:5: style: The function 'date_month' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int date_month(unsigned int date_val) { return (date_val >> 5) & 0xF; }
    ^
src/values.c:17:5: style: The function 'date_day' should have static linkage since it is not used outside of its translation unit. [staticFunction]
int date_day(unsigned int date_val) { return date_val & 0x1F; }
    ^
